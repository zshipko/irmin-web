open Lwt.Infix
open Tyxml

let irmin_js = [%blob "../../js/irmin.js"]

module type S = sig
  type t
  type store
  type server

  val config:
    ?allow_mutations:bool ->
    title:string ->
    html:string ->
    css:string ->
    js:string ->
    store -> t

  val make:
    addr:string
    -> port:int
    -> t
    -> server
end

module Make (Server: Cohttp_lwt.S.Server) (Store : Irmin_graphql.Server.S) = struct

  type t =
    { store : Store.store
    ; title: string
    ; html : string
    ; css : string
    ; js : string
    ; allow_mutations : bool }

  type store = Store.store
  type server = Server.t

  let config ?(allow_mutations = true) ~title ~html ~css ~js store = {store; title; html; css; js; allow_mutations}

  let check t doc =
    let open Graphql_parser in
    if not t.allow_mutations then
      List.for_all
        (fun op ->
           match op with
           | Operation {optype = Mutation; _} ->
             false
           | _ ->
             true )
        doc
    else true

  let graphql t req body =
    let schema = Store.schema t.store in
    Cohttp_lwt.Body.to_string body
    >>= fun body ->
    let json = Ezjsonm.from_string body in
    let query = Ezjsonm.find json ["query"] |> Ezjsonm.decode_string_exn in
    let doc = Graphql_parser.parse query in
    match doc with
    | Ok doc ->
      if check t doc then
        let body = Cohttp_lwt.Body.of_string body  in
        Store.execute_request schema req body
      else Server.respond_string ~status:`Unauthorized ~body:"Encountered blacklisted operation" ()
    | Error _ ->
      Server.respond_string ~status:`Bad_request ~body:"Invalid GraphQL query" ()

  let irmin_js_handler address =
    Server.respond_string
      ~status:`OK
      ~headers:(Cohttp.Header.of_list [("Content-Type", "text/javacript")])
      ~body:(irmin_js
             ^ Printf.sprintf
               "\n\n//Generated by Irmin_web\nlet ir = new Irmin(\"%s\");\n" address
            ) ()

  let make_html t =
    let inner = Tyxml.Html.Unsafe.data t.html in
    let html = [%html {|
      <html>
        <head>
          <meta charset="utf-8">
          <title>|}(Html.txt t.title){|</title>
          <link rel="stylesheet" href="/static/css/main.css" />
          <script src="/irmin.js">//</script>
        </head>
        <body>
          |}[inner]{|
          <script src="/static/js/main.js">//</script>
        </body>
      </html>
    |}] in
    let buffer = Buffer.create 64 in
    let fmt = Format.formatter_of_buffer buffer in
    Tyxml.Html.pp () fmt html;
    Buffer.contents buffer

  let callback t address html _conn req body =
    let uri = Cohttp_lwt.Request.uri req in
    match Uri.path uri with
    | "/graphql" -> graphql t req body
    | "/irmin.js" -> irmin_js_handler address
    | "/static/js/main.js" ->
      let headers = Cohttp.Header.of_list [("Content-Type", "text/javascript")] in
      Server.respond_string ~status:`OK ~headers ~body:t.js ()
    | "/static/css/main.css" ->
      let headers = Cohttp.Header.of_list [("Content-Type", "text/css")] in
      Server.respond_string ~status:`OK ~headers ~body:t.css ()
    | "/" ->
      let headers = Cohttp.Header.of_list [("Content-Type", "text/html")] in
      Server.respond_string ~status:`OK ~headers ~body:html ()
    | _ -> Server.respond_string ~status:`Not_found ~body:"Not found" ()

  let make ~addr ~port t =
    let address = Printf.sprintf "//%s:%d/graphql" addr port in
    let html = make_html t in
    let callback = callback t address html in
    Server.make ~callback ()
end
